{% extends "base.html" %}
{% block title %}AI Text-to-SQL Query Builder{% endblock %}

{% block content %}
<!-- Include Tailwind + Alpine + ApexCharts -->
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

<div class="max-w-7xl mx-auto py-8" 
     x-data="queryPage()"
     @close-logic-modal.window="showLogicModal = false">

  <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

    <!-- LEFT SIDE -->
    <div class="space-y-6">

      <!-- üí¨ Query Input -->
      <div class="bg-white/70 backdrop-blur rounded-2xl shadow-sm p-5 space-y-4">
        <div class="flex justify-between items-center">
          <h2 class="text-lg font-semibold text-gray-800 flex items-center">
            Enter or Edit Your Question
          </h2>
          <a href="/" class="text-sm bg-gray-100 hover:bg-gray-50 text-gray-700 px-3 py-1.5 rounded-lg shadow-sm transition border">
            Change DB
          </a>
        </div>

        <div class="space-y-3">
          <textarea id="queryInput" rows="4"
            class="w-full rounded-lg border border-gray-300 bg-white py-2.5 px-3 text-sm shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 placeholder-gray-400 transition"
            placeholder="e.g., Show me all customers who purchased last week">{{ query or '' }}</textarea>

          <div class="flex flex-wrap gap-3">
            <button
              @click="submitQuery"
              class="bg-indigo-600 text-white px-6 py-2.5 rounded-lg shadow-md hover:bg-indigo-700 transition text-sm font-medium inline-flex items-center justify-center gap-2">
              Generate & Execute SQL
            </button>

            <button
              @click="fetchLogicAndOpen"
              class="bg-gray-100 text-gray-700 px-5 py-2.5 rounded-lg hover:bg-gray-50 transition text-sm font-medium shadow-sm inline-flex items-center justify-center gap-2 border">
              Application Logic
            </button>
          </div>
        </div>
      </div>

      <!-- üß© Schema Used -->
      <div class="bg-white/70 backdrop-blur rounded-2xl shadow-sm p-5" x-data="{ open: false }">
        <div class="flex justify-between items-center cursor-pointer" @click="open = !open">
          <h2 class="text-lg font-semibold text-gray-800 flex items-center">Schema Used</h2>
          <svg x-show="!open" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500"><path d="M5 8l5 5 5-5H5z"/></svg>
          <svg x-show="open" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500"><path d="M15 12l-5-5-5 5h10z"/></svg>
        </div>
        <div x-show="open" x-collapse class="mt-3">
          <pre id="schemaInfo" class="text-xs bg-gray-50 text-gray-700 rounded-lg p-3 overflow-x-auto">{{ schema_info }}</pre>
        </div>
      </div>

      <!-- üìä Results Table -->
      <div class="bg-white/70 backdrop-blur rounded-2xl shadow-sm p-5" x-data="{ open: true }">
        <div class="flex justify-between items-center cursor-pointer" @click="open = !open">
          <h2 class="text-lg font-semibold text-gray-800 flex items-center">Query Results</h2>
          <svg x-show="!open" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500"><path d="M5 8l5 5 5-5H5z"/></svg>
          <svg x-show="open" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500"><path d="M15 12l-5-5-5 5h10z"/></svg>
        </div>
        <div x-show="open" x-collapse class="mt-3 overflow-x-auto">
          <div id="resultsTableContainer">
            {% if rows %}
              <table class="min-w-full text-sm text-gray-700 border border-gray-200 rounded-xl overflow-hidden">
                <thead class="bg-gray-100 text-gray-800">
                  <tr>
                    {% for col in columns %}
                      <th class="px-3 py-2 text-left font-medium border-b border-gray-200">{{ col }}</th>
                    {% endfor %}
                  </tr>
                </thead>
                <tbody>
                  {% for row in rows %}
                    <tr class="even:bg-gray-50 hover:bg-gray-100 transition">
                      {% for col in columns %}
                        <td class="px-3 py-2 border-b border-gray-100">{{ row[col] }}</td>
                      {% endfor %}
                    </tr>
                  {% endfor %}
                </tbody>
              </table>
            {% else %}
              <p class="text-sm text-gray-500 italic">No results returned.</p>
            {% endif %}
          </div>
        </div>
      </div>

    </div>

    <!-- RIGHT SIDE -->
    <div class="space-y-6">

      <!-- üß† SQL Query -->
      <div class="bg-white/70 backdrop-blur rounded-2xl shadow-sm p-5">
        <h2 class="text-lg font-semibold text-gray-800 mb-3">SQL Generated</h2>
        <pre id="sqlBox" class="bg-gray-50 text-xs text-indigo-700 p-3 rounded-lg overflow-x-auto">{{ sql_query }}</pre>
      </div>

      <!-- üìà Enhanced Visualization Section -->
      <div class="bg-white/70 backdrop-blur rounded-2xl shadow-sm p-5">
        <div class="flex justify-between items-center mb-3">
          <h2 class="text-lg font-semibold text-gray-800">AI-Generated Visualization</h2>
          <div class="flex items-center gap-2">
            <span id="chartTypeBadge" class="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full capitalize">
              {{ chart_type }}
            </span>
            {% if recommended_columns and recommended_columns|length > 0 %}
              <span class="text-xs text-gray-500">({{ recommended_columns|join(', ') }})</span>
            {% endif %}
          </div>
        </div>

        <!-- Primary Insight -->
        {% if primary_insight %}
          <p class="text-xs text-gray-600 mb-2 bg-blue-50 p-2 rounded">{{ primary_insight }}</p>
        {% endif %}

        <!-- Chart Title -->
        {% if chart_title %}
          <h3 class="text-md font-medium text-gray-700 mb-2">{{ chart_title }}</h3>
        {% endif %}

        <!-- Chart Description -->
        {% if chart_description %}
          <p class="text-xs text-gray-500 mb-2 italic">{{ chart_description }}</p>
        {% endif %}

        <!-- Chart Container -->
        <div id="chart" class="w-full h-96 flex justify-center items-center text-gray-400 text-sm italic">
          {% if not chart_data %}No chart data{% endif %}
        </div>

        <!-- Multiple chart suggestions (if available) -->
        {% if all_charts and all_charts|length > 1 %}
        <div class="mt-4 pt-4 border-t border-gray-200">
          <h4 class="text-sm font-medium text-gray-700 mb-2">Other Suggested Visualizations:</h4>
          <div class="flex flex-wrap gap-2">
            {% for suggestion in all_charts[1:] %}
            <span class="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded">
              {{ suggestion.chart_name }} ({{ suggestion.chart_type }})
            </span>
            {% endfor %}
          </div>
        </div>
        {% endif %}

        <!-- Chart Data -->
        {% if chart_data %}
          <script id="chart-data-json" type="application/json">{{ chart_data | tojson }}</script>
        {% endif %}
        {% if series_config %}
          <script id="chart-series-json" type="application/json">{{ series_config | tojson }}</script>
        {% endif %}
        {% if recommended_columns %}
          <script id="recommended-columns-json" type="application/json">{{ recommended_columns | tojson }}</script>
        {% endif %}
      </div>

    </div>
  </div>

  <!-- üß† Application Logic Modal -->
  <div x-show="showLogicModal" x-transition.opacity class="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm px-4">
    <div @click.away="showLogicModal = false" class="bg-white rounded-2xl shadow-xl w-full max-w-2xl p-8 space-y-6 border border-gray-100">
      <div class="flex justify-between items-center border-b pb-3">
        <h2 class="text-lg font-semibold text-gray-800">Application Logic</h2>
        <button @click="showLogicModal = false" class="text-gray-500 hover:text-gray-700 text-xl leading-none">x</button>
      </div>
      <div x-show="!isLoading" class="space-y-2">
        <label class="block text-sm font-semibold text-gray-700">Describe your application rules or domain logic:</label>
        <textarea id="logicText" rows="8"
          class="w-full border border-gray-300 rounded-lg text-sm shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 p-3 transition"
          placeholder="Example: In 'project' table, type 'P' means Project and type 'R' means Recipe..."></textarea>
      </div>
      <div class="flex justify-end space-x-3 pt-4 border-t">
        <button @click="showLogicModal = false" class="text-sm px-4 py-2 rounded-lg bg-gray-100 text-gray-700 hover:bg-gray-200 transition font-medium">Cancel</button>
        <button @click="saveLogic" class="text-sm px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition font-medium shadow">Save Logic</button>
      </div>
    </div>
  </div>
</div>

<script>
function queryPage() {
  return {
    showLogicModal: false,
    isLoading: false,

    async submitQuery() {
      const query = document.getElementById("queryInput").value.trim();
      if (!query) return alert("Please enter a question first.");

      const resultsContainer = document.getElementById("resultsTableContainer");
      const sqlBox = document.getElementById("sqlBox");
      const schemaInfo = document.getElementById("schemaInfo");
      const chartDiv = document.getElementById("chart");
      const chartTypeBadge = document.getElementById("chartTypeBadge");

      sqlBox.textContent = "‚è≥ Generating SQL...";
      resultsContainer.innerHTML = `<div class="text-center text-gray-500 py-6 italic">‚è≥ Running query...</div>`;
      chartDiv.innerHTML = `<div class="text-gray-400 italic">Generating chart...</div>`;

      try {
        const res = await fetch("/query", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({ query }),
        });

        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");

        sqlBox.textContent = doc.querySelector("#sqlBox")?.textContent || "No SQL generated.";
        schemaInfo.textContent = doc.querySelector("#schemaInfo")?.textContent || "Schema unavailable.";

        const newTable = doc.querySelector("#resultsTableContainer")?.innerHTML;
        resultsContainer.innerHTML = newTable || "<p class='text-gray-500 italic'>No results.</p>";

        const chartDataScript = doc.querySelector("#chart-data-json")?.textContent || "[]";
        const seriesConfigScript = doc.querySelector("#chart-series-json")?.textContent || "[]";
        const recommendedColumnsScript = doc.querySelector("#recommended-columns-json")?.textContent || "[]";

        const newChartData = JSON.parse(chartDataScript);
        const newSeriesConfig = JSON.parse(seriesConfigScript);
        const newRecommendedColumns = JSON.parse(recommendedColumnsScript);
        const newChartType = doc.querySelector("#chartTypeBadge")?.textContent.trim() || "bar";

        chartTypeBadge.textContent = newChartType;
        
        // Update the columns display
        const columnsDisplay = chartTypeBadge.nextElementSibling;
        if (columnsDisplay && newRecommendedColumns.length > 0) {
          columnsDisplay.textContent = `(${newRecommendedColumns.join(', ')})`;
        }
        
        this.renderChart(newChartData, newSeriesConfig, newChartType);

      } catch (err) {
        resultsContainer.innerHTML = `<div class='text-red-600'>‚ùå Error: ${err.message}</div>`;
      }
    },

    renderChart(chartData, seriesConfig, chartType) {
      const chartDiv = document.getElementById("chart");
      chartDiv.innerHTML = "";
      
      if (!chartData.length) {
        chartDiv.innerHTML = `<div class="text-gray-400 italic">No data to visualize.</div>`;
        return;
      }

      // Handle table visualization
      if (chartType === 'table') {
        this.renderTableVisualization(chartData, chartDiv);
        return;
      }

      // Handle chart visualizations
      if (!seriesConfig.length) {
        chartDiv.innerHTML = `<div class="text-gray-400 italic">No series configuration available.</div>`;
        return;
      }

      const series = [];
      const categories = new Set();

      seriesConfig.forEach(cfg => {
        const x = cfg.x;
        const y = cfg.y;
        const type = cfg.type || chartType;
        const name = cfg.name || y;

        if (!x || !y) return;

        // Group data for aggregation
        const aggregatedData = {};
        chartData.forEach(d => {
          const xVal = d[x];
          const yVal = parseFloat(d[y]);
          
          if (xVal !== undefined && !isNaN(yVal)) {
            categories.add(xVal);
            
            if (cfg.aggregation === 'count') {
              aggregatedData[xVal] = (aggregatedData[xVal] || 0) + 1;
            } else if (cfg.aggregation === 'sum') {
              aggregatedData[xVal] = (aggregatedData[xVal] || 0) + yVal;
            } else if (cfg.aggregation === 'avg') {
              if (!aggregatedData[xVal]) {
                aggregatedData[xVal] = { sum: 0, count: 0 };
              }
              aggregatedData[xVal].sum += yVal;
              aggregatedData[xVal].count += 1;
            } else {
              // No aggregation - use individual points
              aggregatedData[xVal] = yVal;
            }
          }
        });

        // Prepare final data points
        const dataPoints = Array.from(categories).map(category => {
          let value = aggregatedData[category];
          
          if (cfg.aggregation === 'avg' && value && typeof value === 'object') {
            value = value.count > 0 ? value.sum / value.count : 0;
          }
          
          return {
            x: category,
            y: value || 0
          };
        });

        if (dataPoints.length > 0) {
          series.push({
            name: name,
            type: type,
            data: dataPoints
          });
        }
      });

      if (!series.length) {
        chartDiv.innerHTML = `<div class="text-gray-400 italic">No chartable data found.</div>`;
        return;
      }

      const options = {
        chart: {
          type: 'line', // base type
          height: 380,
          toolbar: { show: true },
          stacked: false
        },
        series: series,
        xaxis: {
          type: 'category',
          categories: Array.from(categories),
          labels: { rotate: -45 }
        },
        yaxis: {
          title: { text: "Value" }
        },
        tooltip: {
          shared: true,
          intersect: false
        },
        stroke: {
          width: [2, 2, 2]
        },
        plotOptions: {
          bar: {
            horizontal: false,
            columnWidth: '55%',
          }
        }
      };

      try {
        // ‚úÖ PIE CHART HANDLING
        if (chartType === 'pie' || chartType === 'donut') {
          const xKey = seriesConfig[0]?.x || Object.keys(chartData[0])[0];
          const yKey = seriesConfig[0]?.y || Object.keys(chartData[0])[1];

          const labels = chartData.map(d => d[xKey]);
          const values = chartData.map(d => parseFloat(d[yKey]));

          const options = {
            chart: {
              type: chartType,
              height: 380,
            },
            labels: labels,
            series: values,
            legend: {
              position: 'right'
            },
            tooltip: {
              y: {
                formatter: val => `${val} learners`
              }
            }
          };

          new ApexCharts(chartDiv, options).render();
          return; // ‚úÖ Stop here for pie/donut
        }

        // ‚úÖ DEFAULT (bar/line/scatter/area)
        const options = {
          chart: {
            type: chartType || 'line',
            height: 380,
            toolbar: { show: true },
            stacked: false
          },
          series: series,
          xaxis: {
            type: 'category',
            categories: Array.from(categories),
            labels: { rotate: -45 }
          },
          yaxis: {
            title: { text: "Value" }
          },
          tooltip: {
            shared: true,
            intersect: false
          },
          stroke: {
            width: [2, 2, 2]
          },
          plotOptions: {
            bar: {
              horizontal: false,
              columnWidth: '55%',
            }
          }
        };

        new ApexCharts(chartDiv, options).render();

      } catch (err) {
        console.error("Chart render error:", err);
        chartDiv.innerHTML = `<div class='text-red-500 italic'>Chart rendering failed: ${err.message}</div>`;
      }
    },

    renderTableVisualization(chartData, container) {
      if (!chartData.length) {
        container.innerHTML = `<div class="text-gray-400 italic">No data for table visualization.</div>`;
        return;
      }

      const columns = Object.keys(chartData[0]);
      const html = `
        <div class="overflow-x-auto max-h-96">
          <table class="min-w-full text-sm border border-gray-200 rounded-lg">
            <thead class="bg-gray-50 sticky top-0">
              <tr>
                ${columns.map(col => `<th class="px-3 py-2 text-left font-medium border-b">${col}</th>`).join('')}
              </tr>
            </thead>
            <tbody>
              ${chartData.map(row => `
                <tr class="border-b hover:bg-gray-50">
                  ${columns.map(col => `<td class="px-3 py-2">${row[col] ?? ''}</td>`).join('')}
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      `;
      container.innerHTML = html;
    },

    async fetchLogicAndOpen() {
      this.isLoading = true;
      this.showLogicModal = true;
      try {
        const res = await fetch("/api/get-logic");
        const data = await res.json();
        document.getElementById("logicText").value = data.logic || "";
      } catch (err) {
        alert("Error fetching logic: " + err.message);
      }
      this.isLoading = false;
    },

    async saveLogic() {
      const logic = document.getElementById("logicText").value.trim();
      if (!logic) return alert("Please enter some logic first.");
      try {
        const res = await fetch("/api/save-logic", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ logic }),
        });
        const result = await res.json();
        if (result.status === "success") {
          alert("‚úÖ Logic saved successfully!");
          this.showLogicModal = false;
        } else {
          alert("Error: " + result.error);
        }
      } catch (err) {
        alert("Error saving logic: " + err.message);
      }
    },
  };
}

// Initial chart rendering on page load
document.addEventListener("DOMContentLoaded", () => {
  const chartDataEl = document.querySelector("#chart-data-json");
  const seriesEl = document.querySelector("#chart-series-json");
  const chartDiv = document.getElementById("chart");
  const chartType = document.querySelector("#chartTypeBadge")?.textContent.trim() || "bar";

  if (!chartDataEl) {
    chartDiv.innerHTML = `<div class='text-gray-400 italic'>No visualization available.</div>`;
    return;
  }

  const data = JSON.parse(chartDataEl.textContent || "[]");
  const seriesConfig = JSON.parse(seriesEl?.textContent || "[]");

  if (!data.length) {
    chartDiv.innerHTML = `<div class='text-gray-400 italic'>No chartable data.</div>`;
    return;
  }

  // Use the same rendering logic
  const queryPageInstance = queryPage();
  queryPageInstance.renderChart(data, seriesConfig, chartType);
});
</script>
{% endblock %}